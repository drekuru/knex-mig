import chalk from 'chalk';
import { cleanFileName, Colors, getSeedType, pp } from '../utils';
import { EnvManager } from './env.manager';
import { existsSync, lstatSync, readdirSync } from 'fs';
import { MigrateOptions, SeedNode, SeedType } from '../types';
import path from 'path';
import { Knex } from 'knex';

export class SeedManager {
    private static _tree: SeedNode;
    private static _indexedFiles: Map<number, SeedNode> = new Map();
    private static fileCount: number = 0;

    static get tree(): SeedNode {
        if (!this._tree) {
            this.initFileTree();
        }
        return this._tree;
    }

    static get indexedFiles(): Map<number, SeedNode> {
        if (!this._indexedFiles.size) {
            this.initFileTree();
        }
        return this._indexedFiles;
    }

    static initFileTree(): void {
        // build the tree
        const pathToSeeds = EnvManager.get().SEED_DIR;

        if (!pathToSeeds || !existsSync(pathToSeeds)) {
            pp.error(`Seed directory not found at ${chalk.redBright(pathToSeeds)}`);
            process.exit(1);
        }

        this._tree = this.buildTree(pathToSeeds);
        this._tree.name = '.';
    }

    static printTree(rootNode?: SeedNode): void {
        if (!rootNode) {
            rootNode = this.tree;
        }

        pp.info('Seed Dir:');
        this.printNode(rootNode, true);
    }

    // this was generated by chatgpt
    private static printNode(node: SeedNode, isLast: boolean, prefix: string = ''): void {
        const connector = isLast ? '└── ' : '├── ';

        if (node.isFile) {
            pp.info(`${prefix}${connector}${node.index} - ${node.name}`);
        } else {
            let newPrefix: string;
            if (node.name === '.') {
                pp.info(`${prefix}${node.name}`);
                newPrefix = prefix + (isLast ? '' : '│');
            } else {
                pp.info(`${prefix}${connector}${Colors.orange(node.name)}`);
                newPrefix = prefix + (isLast ? '    ' : '│   ');
            }
            const children = Array.from(node.children?.values() || []);
            children.forEach((child, index) => {
                const isLastChild = index === children.length - 1;
                this.printNode(child, isLastChild, newPrefix);
            });
        }
    }

    // recursive function to build the tree
    private static buildTree(nodePath: string): SeedNode {
        const stats = lstatSync(nodePath);
        const name = path.basename(nodePath);

        if (stats.isDirectory()) {
            const node: SeedNode = {
                fullPath: nodePath,
                name,
                children: new Map(),
                isFile: false
            };

            const files = readdirSync(nodePath);

            for (const file of files) {
                const childPath = `${nodePath}/${file}`;
                const childNode = this.buildTree(childPath);

                node.children?.set(childNode.name, childNode);
            }

            return node;
        } else {
            const extension = path.extname(name);
            const node: SeedNode = {
                fullPath: nodePath,
                name: cleanFileName(name),
                isFile: true,
                extension,
                index: ++this.fileCount,
                seedType: getSeedType(extension)
            };

            this._indexedFiles.set(node.index!, node);

            return node;
        }
    }

    public static getFile(filepath: string): SeedNode | undefined {
        let currentNode = this.tree;

        // check if filepath is actually an integer
        if (!isNaN(parseInt(filepath))) {
            return this.getFileByIndex(parseInt(filepath));
        }

        const parts = filepath.split('/');

        for (const part of parts) {
            const child = currentNode.children?.get(part);

            if (!child) {
                return undefined;
            }

            currentNode = child;
        }

        return currentNode;
    }

    private static getFileByIndex(index: number): SeedNode | undefined {
        return this.indexedFiles.get(index);
    }

    static prepareSeedFiles(filenames: string[], options: MigrateOptions): SeedNode[] {
        const filesToProcess: Map<number, SeedNode> = new Map();

        if (options.all) {
            const allFiles = Array.from(this.indexedFiles.values());
            allFiles.forEach((file) => filesToProcess.set(file.index!, file));
        } else {
            for (const filename of filenames) {
                const file = this.getFile(filename);

                if (file) {
                    filesToProcess.set(file.index!, file);
                }
            }
        }

        if (options.but?.length) {
            // get files
            for (const exclude of options.but) {
                const fileToExclude = this.getFile(exclude);

                if (fileToExclude) {
                    filesToProcess.delete(fileToExclude.index!);
                }
            }
        }

        return Array.from(filesToProcess.values());
    }

    static async runSeed(seed: SeedNode, trx: Knex.Transaction): Promise<void> {
        const baseMsg = `Seed [${Colors.yellowOlive(`${seed.index} - ${seed.name}`)}]`;
        try {
            pp.info(`${baseMsg}: RUNNING`);

            if (seed.seedType === SeedType.DYNAMIC) {
                const seedFn = require(seed.fullPath);
                await seedFn.seed(trx);
            } else if (seed.seedType === SeedType.STATIC) {
                await this.handleStaticSeed(seed, trx);
            } else {
                pp.error(`Seed type not supported for [${Colors.yellowOlive(seed.name)}]`);
                return;
            }

            pp.info(`${baseMsg}: SUCCEEDED`);
        } catch (err) {
            pp.info(`${baseMsg}: ${Colors.indianRed('FAILED')}`);
            pp.error(err);
            process.exit(1);
        }
    }

    private static async handleStaticSeed(seed: SeedNode, trx: Knex.Transaction): Promise<void> {
        const seedJson = require(seed.fullPath);

        // if its missing fields, throw an error
        for (const field of ['schema', 'table', 'unique', 'data']) {
            if (!seedJson[field]) {
                pp.error(`Seed [${seed.name}] is missing field [${field}]`);
                return;
            }
        }

        const res = await trx(seedJson.table)
            .withSchema(seedJson.schema)
            .insert(seedJson.data)
            .onConflict(seedJson.unique)
            .merge();

        pp.debug(res);
    }
}
