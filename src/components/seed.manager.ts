import chalk from 'chalk';
import { cleanFileName, Colors, getSeedType, pp } from '../utils';
import { EnvManager } from './env.manager';
import { existsSync, lstatSync, readdirSync } from 'fs';
import { SeedNode, SeedType } from '../types';
import path from 'path';
import { Knex } from 'knex';

export class SeedManager {
    private static tree: SeedNode;
    private static fileCount: number = 0;

    static initFileTree(): void {
        if (!this.tree) {
            // build the tree
            const pathToSeeds = EnvManager.get().SEED_DIR;

            if (!pathToSeeds || !existsSync(pathToSeeds)) {
                pp.error(`Seed directory not found at ${chalk.redBright(pathToSeeds)}`);
                process.exit(1);
            }

            this.tree = this.buildTree(pathToSeeds);
            this.tree.name = '.';
        }
    }

    static printTree(rootNode?: SeedNode): void {
        this.initFileTree();

        if (!rootNode) {
            rootNode = this.tree;
        }

        pp.info('Seed Dir:');
        this.printNode(rootNode, true);
    }

    // this was generated by chatgpt
    private static printNode(node: SeedNode, isLast: boolean, prefix: string = ''): void {
        const connector = isLast ? '└── ' : '├── ';

        if (node.isFile) {
            pp.info(`${prefix}${connector}${node.index} - ${node.name}`);
        } else {
            let newPrefix;
            if (node.name === '.') {
                pp.info(`${prefix}${node.name}`);
                newPrefix = prefix + (isLast ? '' : '│');
            } else {
                pp.info(`${prefix}${connector}${Colors.orange(node.name)}`);
                newPrefix = prefix + (isLast ? '    ' : '│   ');
            }
            const children = Array.from(node.children?.values() || []);
            children.forEach((child, index) => {
                const isLastChild = index === children.length - 1;
                this.printNode(child, isLastChild, newPrefix);
            });
        }
    }

    // recursive function to build the tree
    private static buildTree(nodePath: string): SeedNode {
        const stats = lstatSync(nodePath);
        const name = path.basename(nodePath);

        if (stats.isDirectory()) {
            const node: SeedNode = {
                fullPath: nodePath,
                name,
                children: new Map(),
                isFile: false
            };

            const files = readdirSync(nodePath);

            for (const file of files) {
                const childPath = `${nodePath}/${file}`;
                const childNode = this.buildTree(childPath);

                node.children?.set(childNode.name, childNode);
            }

            return node;
        } else {
            const extension = path.extname(name);
            const node: SeedNode = {
                fullPath: nodePath,
                name: cleanFileName(name),
                isFile: true,
                extension,
                index: ++this.fileCount,
                seedType: getSeedType(extension)
            };

            return node;
        }
    }

    public static getFile(filepath: string): SeedNode | undefined {
        this.initFileTree();

        const parts = filepath.split('/');
        let currentNode = this.tree;

        for (const part of parts) {
            const child = currentNode.children?.get(part);

            if (!child) {
                return undefined;
            }

            currentNode = child;
        }

        return currentNode;
    }

    static async runSeed(seed: SeedNode, trx: Knex.Transaction): Promise<void> {
        pp.info(`Running seed [${seed.name}]`);

        if (seed.seedType === SeedType.DYNAMIC) {
            await trx.transaction(async (trx) => {
                const seedFn = require(seed.fullPath);
                await seedFn.seed(trx);
                pp.log(`Seed [${seed.name}] ran successfully`);
            });
        } else if (seed.seedType === SeedType.STATIC) {
            await this.handleStaticSeed(seed, trx);
        } else {
            pp.error(`Seed type not supported for [${seed.name}]`);
            return;
        }
    }

    private static async handleStaticSeed(seed: SeedNode, trx: Knex.Transaction): Promise<void> {
        const seedJson = require(seed.fullPath);

        // if its missing fields, throw an error
        for (const field of ['schema', 'table', 'unique', 'data']) {
            if (!seedJson[field]) {
                pp.error(`Seed [${seed.name}] is missing field [${field}]`);
                return;
            }
        }

        await trx(seedJson.table)
            .withSchema(seedJson.schema)
            .insert(seedJson.data)
            .onConflict(seedJson.unique)
            .merge()
            .catch((err) => {
                pp.error(`Error running seed [${seed.name}]`);
                pp.error(err);
            });
    }
}
